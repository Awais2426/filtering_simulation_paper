---
title: "Box 2 and Wahlund from Box 1"
output: html_document
date: "2023-06-24"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table); library(ggplot2); library(cowplot); library(snpR)
```


# Prepare the data:
## Run the simulations

To generate the results processed here, run:

1. `gen_filter_parms.R`: This will prepare parameter file with the filters, named `filt_parms.txt`. Another
text file, named `filt_jobs.txt` contains information on the jobs to run, with the first column noting the processed, `snpRdata` files, the outfile names, the memory requested (in G), a logical indicating if $F_{ST}$ values for each individual SNP are requested in addition to means, and a logical indicating if site frequency spectra should be calculated. If you wish to change parameters, do so here, then make sure you update the array count `#SBATCH --array=1-x` to set `x` to the number of parameter sets in the `filt.sh` script.
  - `snpRdata` input files should have no periods or other special characters in the chromosome column of the snp metadata, which should be named `chr`, or in the population column of the sample metadata, which should be named `pop`. The `format.R` and `format.sh` scripts provide formatting tools for this, assuming `.vcf` files and another `sample_meta.txt` file which contains two columns: population ID and sample ID (matching the `vcf` header sample IDs).
2. `multirun_filt.sh`: This will run the filtering pipeline with the given jobs and filtering sets, queuing an `SBATCH` array job after adjusting the requested memory for each listed job. This runs `filt.sh`, which runs `filt.R` for each job and filter set.
3. `structure_for_box_2.R`: Will run STRUCTURE on the monarch data for $k = 3$ with MAC filters of 0-11. Note it does so on a subset of 3819 SNPs to be equivalent to [Linck and Battey 2019](https://doi.org/10.1111/1755-0998.12995).

These scripts are separate from this `.Rmd` to allow for SLURM job handling and more efficient parallelization.


# Panel A

## Set-up parameters

This chunk prepares some information for plotting the figure for Box 1. Specifically, it reads in the filtering parameters in case such are requested, then sets up aliases for statistics and lists the populations to analyze.

```{r setup}
filter_parms <- fread("filt_parms.txt")
filter_parms[,filter_ID := 1:nrow(filter_parms)]

stat_key <- data.frame(stat = c("weighted_mean_he",
                                "weighted_mean_ho",
                                "weighted_mean_pi",
                                "weighted_mean_fis",
                                "global_ws.theta",
                                "global_ts.theta",
                                "global_D",
                                "seg_sites",
                                "total_pa_corrected",
                                "LDNe_0",
                                "weighted_mean_fst"),
                       fix = c("H[e]",
                               "H[o]",
                               "pi",
                               "F[IS]", 
                               "Watterson*'\\''*'s'*' '*theta",
                               "Tajima*'\\''*'s'*' '*theta",
                               "Tajima*'\\''*'s'*' D'",
                               "P[seg]",
                               "P[private]",
                               "log[10](N[e])",
                               "F[ST]"))

keep_data <- c("humans", "monarchs", "goats_WGS", "goats_RAD",
               "orcas", "stoneflies", "yellowperch", "mice", "deer",
               "expansion", "bottleneck", "neutral", "arabidopsis")

plot_stats <- c("weighted_mean_fst",
                "weighted_mean_ho",
                "weighted_mean_fis",
                "global_D")
plot_stats <- stat_key$fix[match(plot_stats, stat_key$stat)]

colors <- as.character(khroma::color("muted")(9))
colors <- c(as.character(khroma::color("bright")(3)),
            as.character(khroma::color("vibrant")(1)), colors)
```

## Read in the filtering results

This chunk reads in the averages for the different genetic variance statistics. Variance for most statistics will be in the object `stats` and for $F_{ST}$ in `fst`.

```{r}
# read in single-pop stats
stats_files <- list.files("../data/emperical/outfiles/", "stats\\.txt", full.names = TRUE)
stats_files <- c(stats_files, list.files("../data/simulated/outfiles/", "^[a-z].+stats\\.txt", full.names = TRUE))

stats <- lapply(stats_files, fread)
names(stats) <- stats_files

stats <- rbindlist(stats, idcol = "run_ID")
stats[,contour := grepl("contour", run_ID)]
stats[, filter_ID := as.numeric(gsub("r", "", stringr::str_extract(run_ID, "r[0-9]+")))]
stats[, dataset := gsub("outfiles/", "", gsub("___", "", stringr::str_extract(run_ID, "outfiles/.+___")))]
stats[,dataset := gsub("_contour", "", dataset)]
stats[,LDNe_0 := log10(LDNe_0)]

stats <- stats[dataset %in% keep_data,]
stats[,dataset := gsub("_", " ", dataset)]
stats[,dataset := gsub("goats", "Mountain Goats", dataset)]
stats[,dataset := gsub("yellowperch", "Yellow Perch", dataset)]



contour_stats <- stats[which(contour),]
stats <- stats[-which(contour),]

# dplyr::arrange(unique(stats[,c("maf", "mgc", "hwe", "min_ind", "min_loci", "LD", "filter_ID")]), maf)


 # read in fst
fst_files <- list.files("../data/emperical/outfiles/", "fst\\.txt", full.names = TRUE)
fst_files <- c(fst_files, list.files("../data/simulated/outfiles/", "^[a-z].+fst\\.txt", full.names = TRUE))


fst <- lapply(fst_files, fread)
names(fst) <- fst_files

fst <- rbindlist(fst, idcol = "run_ID")
fst[, filter_ID := as.numeric(gsub("r", "", stringr::str_extract(run_ID, "r[0-9]+")))]
fst[, dataset := gsub("outfiles/", "", gsub("___", "", stringr::str_extract(run_ID, "outfiles/.+___")))]
fst[,contour := grepl("contour", run_ID)]
fst[,dataset := gsub("_contour", "", dataset)]

fst <- fst[dataset %in% keep_data,]
fst[,dataset := gsub("_", " ", dataset)]
fst[,dataset := gsub("goats", "Mountain Goats", dataset)]
fst[,dataset := gsub("yellowperch", "Yellow Perch", dataset)]
fst$mean_fst <- NULL

fst_contour <- fst[which(contour),]
fst <- fst[-which(contour),]
```

## Function to prepare one filter
This is a function to prepare both the stats and fst data a set of filter indices (for one filter).
```{r prepare_filt_func}
prepare_one_filter <- function(stats, fst, tfilt_indices, tfilt_ref){
  
  stats <- stats[,-c("contour")]
  fst <- fst[,-c("contour")]

  ## stats
  tfilt_stats <- stats[filter_ID %in% c(tfilt_indices),]
  
  tfilt_stats[,seg_sites := seg_sites/max(seg_sites), by = .(subfacet, dataset)]
  tfilt_stats[,total_pa_corrected := total_pa_corrected/max(total_pa_corrected), by = .(subfacet, dataset)]
  
  mtfilt_stats <- melt(tfilt_stats, id.vars = c("run_ID", "subfacet", "maf", "mgc", 
                                            "hwe", "min_ind", "min_loci", "LD", 
                                            "filter_ID", "dataset"), 
                     variable.name = "statistic")
  
  mtfilt_stats <- mtfilt_stats[-which(is.infinite(value)),]
  starting_points <- mtfilt_stats[filter_ID == tfilt_ref,]
  mtfilt_stats[,val_at_zero := starting_points$value[match(paste0(dataset, "&", subfacet, "&", statistic),
                                                         paste0(starting_points$dataset, "&", starting_points$subfacet, "&", starting_points$statistic))]]
  mtfilt_stats[,zero_normed := value - val_at_zero]
  
  mtfilt_stats[,statistic := stat_key$fix[match(statistic, stat_key$stat)]]
  
  ## fst
  #dplyr::arrange(unique(fst[,c("maf", "mgc", "hwe", "min_ind", "min_loci", "LD", "filter_ID")]), maf)
  tfilt_fst <- fst[filter_ID %in% tfilt_indices,]
  
  mtfilt_fst <- melt(tfilt_fst, id.vars = c("run_ID", "subfacet", "maf", "mgc", 
                                        "hwe", "min_ind", "min_loci", "LD", 
                                        "filter_ID", "dataset"), 
                   variable.name = "statistic")
  
  starting_points <- mtfilt_fst[filter_ID == tfilt_ref,]
  mtfilt_fst[,val_at_zero := starting_points$value[match(paste0(dataset, "&", subfacet, "&", statistic),
                                                       paste0(starting_points$dataset, "&", starting_points$subfacet, "&", starting_points$statistic))]]
  mtfilt_fst[,zero_normed := value - val_at_zero]
  
  mtfilt_fst[,statistic := stat_key$fix[match(statistic, stat_key$stat)]]
  
  
  ## bind
  pstats <- rbind(mtfilt_stats, mtfilt_fst)
  # pstats <- pstats[which(statistic %in% plot_stats),]
  pstats[,type := ifelse(dataset %in% c("neutral", "expansion", "bottleneck"), "Simulated", "Emperical")]
  pstats[,dataset := R.utils::capitalize(dataset)]
  if(any(pstats$type == "Simulated" & pstats$subfacet == "B")){
    pstats <- pstats[-which(type == "Simulated" & subfacet == "B"),]
  }
  pstats[,dataset := factor(dataset, unique(c("Neutral", "Bottleneck", "Expansion", unique(dataset), sort = F)))]
  pstats[,statistic := factor(statistic, unique(c(plot_stats, unique(statistic)), sort = F))]
  
  # set zero-normed back to the raw values for Tajima's D alone
  # pstats[statistic == "Tajima*'\\''*'s'*' D'", zero_normed := value]
  
  
  pstats[,adj_stat_names := paste0("Delta ~ ", statistic)]
  
  return(pstats)
}

exclude_dataset <- function(d, dataset = "arabidopsis", exlusion = list(arabidopsis = c("weighted_mean_ho", "weighted_mean_fis"))){
  for(i in 1:length(dataset)){
    texcl <- exlusion[[dataset[i]]]
    texcl <- stat_key$fix[match(texcl, stat_key$stat)]
    d <- d[-which(dataset == dataset[i] & statistic %in% texcl),]
  }
  
  return(d)
}

inset_plots <- function(pstats, target_statistic){
  target_statistic <- stat_key$fix[match(target_statistic, stat_key$stat)]
  pstats <- pstats[statistic == target_statistic,]
  fis_range <- pstats[,.(min = min(value), max = max(value)), by = .(dataset, subfacet, type)]
  p <- ggplot(fis_range, aes(ymin = min, ymax = max, x = dataset, group =
                               interaction(dataset, subfacet), color = dataset)) +
    geom_linerange(linewidth = 8, position = position_dodge(width = .7)) +
    geom_point(aes(y = min), position = position_dodge(width = .7), size = 7) +
    geom_point(aes(y = max), position = position_dodge(width = .7), size = 7) +
    scale_color_manual(values = colors) +
    guides(color = "none") +
    theme_bw() +
    theme(axis.text.x = element_blank(),
          axis.title = element_blank(),
          axis.text.y = element_text(size = 60),
          axis.ticks.x = element_blank())
  
  return(p)
}

```


## Prepare the plot for maf vs all of the stats of interest. Prepare a plot for *all* statistics vs maf for the supplementary material.

This will plot the maf filter results (if run with the provided `filt_parms.txt`, filter indices 3:12). A `ggplot2` object will be generated named `PA_maf` for panel A, an object name `maf_SI` for the supplementary material, and an interactive figure generated and saved that are not directly part of the paper.

Notes: 

1) Tajima's D alone is not normalized to show the change rather than the raw value, since the flip from negative to positive is biologically important and everything is similar in scale (due to how Tajima's D works).
2) The monarch data are excluded from $F_{ST}$ since they change notably more and thus make everything else difficult to see. They start far more differentiated ($F_{ST} > 0.3$) at maf = 0 as well.

```{r maf_vs_variance}
maf_indices <- 3:12
maf_ref <- 3

pstats <- prepare_one_filter(stats, fst, maf_indices, maf_ref)
pstats <- exclude_dataset(pstats)

## plot
PA_maf <- ggplot(pstats[statistic %in% plot_stats &
                !(statistic == "F[ST]" & dataset == "Monarchs"),], 
       aes(x = maf, y = zero_normed, 
           group = interaction(dataset, subfacet), 
           color = dataset, linetype = type)) + 
  geom_line(size = 1.5) +
  facet_wrap(~adj_stat_names, scales = "free_y", labeller = label_parsed, nrow = 1) +
  scale_color_manual(values = colors) +
  theme_bw() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 16),
        axis.text.x = element_text(angle = 90),
        strip.text = element_text(size = 20),
        strip.background = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  ylab(expression(Delta ~ 'Statistic')) +
  xlab("MAF filter") +
  guides(color = guide_legend(title = "Data Source"),
         linetype = guide_legend(title = "Data Type"))

maf_SI <- ggplot(pstats, 
       aes(x = maf, y = zero_normed, 
           group = interaction(dataset, subfacet), 
           color = dataset, linetype = type)) + 
  geom_line(size = 1.5) +
  facet_wrap(~statistic, scales = "free_y", labeller = label_parsed, nrow = 4) +
  scale_color_manual(values = colors) +
  theme_bw() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 16),
        axis.text.x = element_text(angle = 90),
        strip.text = element_text(size = 20),
        strip.background = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  ylab(expression(Delta ~ 'Statistic')) +
  xlab("MAF filter") +
  guides(color = guide_legend(title = "Data Source"),
         linetype = guide_legend(title = "Data Type"))


maf_interactive <- plotly::ggplotly(ggplot(pstats, aes(x = maf, y = zero_normed, group = interaction(dataset, subfacet), color = dataset, linetype = type)) +
                                      geom_line() +
                                      facet_wrap(~statistic, scales = "free_y", labeller = label_parsed) +
                                      khroma::scale_color_batlow(discrete = TRUE) +
                                      ylab(expression(Delta ~ 'Statistic')))

# maf_interactive
# htmlwidgets::saveWidget(maf_interactive, file = "results/interactive_maf.html", selfcontained = TRUE)

```

## prepare the insets for PA, top
```{r pa_top_insets}
insets_PA_top <- c("weighted_mean_fis", "weighted_mean_fst", "weighted_mean_ho", "global_D")
insets_PA_top <- lapply(insets_PA_top, function(x) inset_plots(pstats, x))
```

## Prepare the plot for filters vs seg sites.
Creates a plot named "PA_ss" for seg-sites vs every filter. This will also prepare and plot the remaining SI figures for every other stat vs each summary statistic, named hwe_SI, min_ind_SI, min_loci_SI, missing_SI.

```{r seg_sites_vs_filters}
#=======================HWE=======================
hwe_indices <- c(2, 13, 14, 43, 44, 45, 46)
hwe_ref <- 13

hwe_pstats <- prepare_one_filter(stats, fst, hwe_indices, hwe_ref)
hwe_pstats$focus_stat <- "log10(HWE)"
hwe_pstats$focus_value <- hwe_pstats$hwe
hwe_pstats[,focus_value := log10(focus_value)]
#=======================missing data--both=======================
miss_indices <- 15:23
miss_ref <- 15

miss_pstats <- prepare_one_filter(stats, fst, miss_indices, miss_ref)
miss_pstats$focus_stat <- "Required % Genotyped"
miss_pstats$focus_value <- miss_pstats$min_ind * 100

#=======================missing data--inds=======================
imiss_indices <- 25:33
imiss_ref <- 25

imiss_pstats <- prepare_one_filter(stats, fst, imiss_indices, imiss_ref)
imiss_pstats$focus_stat <- "Bad Loci"
imiss_pstats$focus_value <- imiss_pstats$min_ind

#=======================missing data--loci=======================
lmiss_indices <- 34:42
lmiss_ref <- 34

lmiss_pstats <- prepare_one_filter(stats, fst, lmiss_indices, lmiss_ref)
lmiss_pstats$focus_stat <- "Bad Individuals"
lmiss_pstats$focus_value <- lmiss_pstats$min_loci

#=======================contour==================================
contour_indices <- 1:50
contour_ref <- 1

contour <- prepare_one_filter(contour_stats, 
                              fst_contour, 
                              contour_indices, contour_ref)
contour <- contour[statistic == "P[seg]",]

#=======================combine data and plot, pseg====================
pstats$focus_stat <- "MAF"
pstats$focus_value <- pstats$maf

all_pstats <- rbind(pstats, hwe_pstats, miss_pstats)
all_pstats[,focus_stat := factor(focus_stat, c("MAF", "log10(HWE)", "Required % Genotyped"))]
ss_pstats <- all_pstats[statistic == "P[seg]",]

total_range <- c(min(c(ss_pstats$value, contour$value)),
                     max(c(ss_pstats$value, contour$value)))

PA_ss <- ggplot(ss_pstats, 
       aes(x = focus_value, y = value, 
           group = interaction(dataset, subfacet), 
           color = dataset, linetype = type)) + 
  geom_line(size = 1.5) +
  facet_wrap(~focus_stat, scales = "free_x", nrow = 1, strip.position = "bottom") +
  scale_color_manual(values = colors) +
  theme_bw() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 16),
        axis.text.x = element_text(angle = 90),
        axis.title.x = element_blank(),
        strip.text = element_text(size = 20),
        strip.placement = "bottom",
        strip.background = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  scale_y_continuous(limits = total_range) + 
  ylab(expression(Delta ~ P[seg])) +
  xlab("Filter Threshold") +
  guides(color = guide_legend(title = "Data Source"),
         linetype = guide_legend(title= "Data Type"))

PA_ss_l <- ggpubr::get_legend(PA_ss)
PA_ss <- PA_ss + guides(color = "none", linetype = "none")

PA_contour <- ggplot(contour[statistic == "P[seg]"  & dataset %in% c("Stoneflies", "Mountain Goats RAD"),],
                     aes(x = maf, y = value, color = log10(hwe), 
                         group = interaction(hwe, dataset, subfacet),  
                         linetype = dataset)) +
  geom_line(size = 1.5) +
  khroma::scale_color_batlow() +
  khroma::scale_fill_batlow() +
  theme_bw() +
  scale_y_continuous(limits = total_range) +
  theme(axis.title.x = element_text(size = 20),
        axis.text = element_text(size = 16),
        axis.text.x = element_text(angle = 90),
        axis.title.y = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank()) +
  guides(linetype = guide_legend(title = "Data Source"),
         color = guide_legend(title = "log10(HWE)")) +
  xlab("MAF")

PA_contour_l <- ggpubr::get_legend(PA_contour)
PA_contour <- PA_contour + guides(linetype = "none",
                                  color = "none")

```

## Combine Panel A

Create the final Panel A

```{r panel_A}
PA_bottom <- plot_grid(PA_ss, PA_contour, rel_widths = c(.75, .25), align = "h", axis = "b") # manually place the legend as an inset

PA <- plot_grid(plot_grid(PA_maf + guides(color = "none", linetype = "none"), PA_bottom, ncol = 1), 
                PA_ss_l, nrow = 1,
                rel_widths = c(1, .2)) # manually place insets on top plot

insets <- c(insets_PA_top, list(PA_contour_l))
names(insets) <- c("top1.pdf", "top2.pdf", "top3.pdf", "top4.pdf", "bottomL.pdf")
for(i in 1:length(insets)){
  save_plot(paste0("../manuscript/final_figures/Figure_Box1A_inset_", names(insets)[i]),
            insets[[i]], base_height = 10, base_width = 12)
}

save_plot("../manuscript/final_figures/Figure_Box1_PA.pdf", PA, base_height = 11, base_width = 18)

```

# Panel B

## Read in the site frequency spectra for the three simulated datasets

This will read in the site frequence spectra data for each filter set in the three simulated data scenarios

```{r read_sfs}
sfs_files <- list.files("../data/simulated/outfiles/", "expansion.+sfs\\.txt$", full.names = TRUE)
sfs_files <- c(sfs_files, list.files("../data/simulated/outfiles/", "bottleneck.+sfs\\.txt$", full.names = TRUE))
sfs_files <- c(sfs_files, list.files("../data/simulated/outfiles/", "neutral.+sfs\\.txt$", full.names = TRUE))


sfs <- lapply(sfs_files, data.table::fread)
names(sfs) <- sfs_files
sfs <- rbindlist(sfs, idcol = "demography")
sfs$filter_ID <- gsub(".+__r", "", sfs$demography)
sfs$filter_ID <- gsub("_sfs\\.txt", "", sfs$filter_ID)
sfs$demography <- ifelse(grepl("expansion", sfs$demography), "Expansion", ifelse(grepl("bottleneck", sfs$demography), "Bottleneck", "Neutral"))
sfs <- sfs[pop == "C",]
```

## Generate the three plots (neutral, expansion, bottleneck)

Generates plots for each demography, making sure that the axes are the same

```{r plot_sfs}
maf_indices <- 3:12

range <- range(sfs[filter_ID %in% maf_indices & proj_prop == .7 & num_min_alleles > 1,]$count)
range <- log10(range)

sfs_netural <- ggplot(sfs[filter_ID %in% maf_indices & proj_prop == .7 & num_min_alleles > 1 &
                            demography == "Neutral",],
       aes(x = num_min_alleles, y = log10(count), color = maf, group = filter_ID)) +
  geom_line(linewidth = 1.5) +
  theme_bw() +
  khroma::scale_color_batlow(range = c(0, .8)) +
  guides(color = guide_legend(title = "MAF filter")) +
  xlab("Minor Allele Count") +
  ylab(expression(log[10](Loci))) +
  theme(axis.title = element_text(size = 10),
        axis.text = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  scale_y_continuous(limits = range)

sfs_legend <- ggpubr::get_legend(sfs_netural)
sfs_netural <- sfs_netural +
  guides(color = "none")

sfs_bottle <- ggplot(sfs[filter_ID %in% maf_indices & proj_prop == .7 & num_min_alleles > 1 &
                            demography == "Bottleneck",],
       aes(x = num_min_alleles, y = log10(count), color = maf, group = filter_ID)) +
  geom_line(linewidth = 1.5) +
  theme_bw() +
  khroma::scale_color_batlow(range = c(0, .8)) +
  guides(color = guide_legend(title = "MAF filter")) +
  xlab("Minor Allele Count") +
  ylab(expression(log[10](Loci))) +
  theme(axis.title = element_text(size = 10),
        axis.text = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  scale_y_continuous(limits = range) +
  guides(color = "none")


sfs_expansion <- ggplot(sfs[filter_ID %in% maf_indices & proj_prop == .7 & num_min_alleles > 1 &
                            demography == "Expansion",],
       aes(x = num_min_alleles, y = log10(count), color = maf, group = filter_ID)) +
  geom_line(linewidth = 1.5) +
  theme_bw() +
  khroma::scale_color_batlow(range = c(0, .8)) +
  guides(color = guide_legend(title = "MAF filter")) +
  xlab("Minor Allele Count") +
  ylab(expression(log[10](Loci))) +
  theme(axis.title = element_text(size = 10),
        axis.text = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  scale_y_continuous(limits = range) +
  guides(color = "none")
```

## Generate curves for the demographic history

This generates the demographic data curve. Ensure that the parameters match those used to
simulate the data in `simulate_data.rmd`, as they should by default. This chunk sets those

```{r demo_curves_parameters}
N0 <- 10000 # starting population size (at present)
mu <- 1e-8 # per-base mutation rate
len <- 10000000 # chromosome length
r <- 1 # average number of recombination events per chr
g <- 1 # years per gen
t1 <- 500 # time of ingroup split
t2 <- 1000 # time of outgroup split
tb <- 50 # time of bottleneck/growth for size change models -- for the slection model this is 50
m <- .1/N0 # number of migrants per gen, near isolation (Fst ~ .1); 10/N0, 50/N0, 100/N0 for low geneflow, mod geneflow, high geneflow
g_size <- 10 # proportion change, .05 for bottle, 10 for expansion
b_size <- .05 # proportion change, .05 for bottle, 10 for expansion
samples <- 50 # sample size
length_growth <- 5 # number of generations where population size is ramping up or down
```

And this chunk does the lines, plotting for twice the time since the bottleneck/growth:

```{r demo_curves}
curve_neutral <- rep(N0, (tb/g)*2)

exp_growth <- function(N0, r, t) N0*exp(r*t)
solve_rate <- function(N0, Nt, t) log(Nt/N0)/t

curve_bottle <- c(rep(N0, tb/g),
                  exp_growth(N0, solve_rate(N0, N0*b_size, length_growth/g), 1:(length_growth/g)),
                  rep(N0*b_size, tb-(length_growth/g)))

curve_exp <- c(rep(N0, tb/g),
               exp_growth(N0, solve_rate(N0, N0*g_size, length_growth/g), 1:(length_growth/g)),
               rep(N0*g_size, tb-(length_growth/g)))
```

This chunk plots those curves on the same plot:

```{r plot_demo}
demos <- rbind(data.table(Demography = "Bottleneck", N = curve_bottle),
               data.table(Demography = "Expansion", N = curve_exp))
demos$Generation <- rep(1:length(curve_neutral), 2)
demos[, Demography := factor(Demography, c("Bottleneck", "Expansion"))]

demo_plot <- ggplot(demos, aes(x = Generation, y = log10(N), group = Demography)) +
  geom_line(size = 1.5) +
  theme_bw() +
  theme(axis.title = element_text(size = 20),
        axis.text = element_text(size = 16),
        axis.text.x = element_text(angle = 90),
        strip.text = element_text(size = 20),
        strip.background = element_blank(),
        legend.text = element_text(size = 16),
        legend.title = element_text(size = 20)) +
  ylab(expression(log[10](N))) +
  xlab("Generation") +
  scale_y_continuous(expand = c(.2, .2))
  

```

## Add on the SFS plots--generate Panel B

```{r PB}
inset_size <- .3
PB <-  ggdraw() +
  draw_plot(demo_plot) +
  draw_plot(sfs_netural, x = .15, y = .59, width = inset_size, height = inset_size/2) +
  draw_plot(sfs_bottle, x = .64, y = .08, width = inset_size, height = inset_size/2) +
  draw_plot(sfs_expansion, x = .64, y = .84, width = inset_size, height = inset_size/2)


PB <- plot_grid(PB,
                sfs_legend,
                rel_widths = c(1, .2))

save_plot("../manuscript/final_figures/Figure_Box1_PB.pdf", PB, base_height = 11, base_width = 7.5)
```


# Panel C -- PCA

## Read in the data

This is 50000k SNPs from the monarch data set, all populations. It was pre-filtered like this:

* a minimum HWE p-value of $1 \times 10^{-6}$ with the facet `pop`.
* a minimum MGC of 1.
* keep individuals sequenced only in 50% of loci
* keep loci sequenced only in 50% of individuals

```{r read_pca}
pcad <- readRDS("../data/monarchs_for_pca.RDS")
```

## prepre PCAs with missing data and maf

We'll compare this to a stricter maf (0.05 in any population) and to a sticter missingness cuttoff (25% missing only allowed in either loci or individuals).

```{r pca_prep}
# base
pcad_base <- pcad
pcad_basep <- plot_clusters(pcad_base, "pop", simplify_output = TRUE, verbose = FALSE)


# strict maf
pcad_maf05 <- filter_snps(pcad,
                         maf = 0.05, maf_facets = "pop",
                         min_ind = .5, min_loci = .5)
pcad_maf05p <- plot_clusters(pcad_maf05, "pop", simplify_output = TRUE, verbose = FALSE)

# strict missingness
# pcad_miss50 <- pcad
# pcad_miss50p <- plot_clusters(pcad_miss50, "pop", simplify_output = TRUE, verbose = FALSE)


pcad_miss75 <- filter_snps(pcad,
                           min_ind = .75, min_loci = .75)
pcad_miss75p <- plot_clusters(pcad_miss75, "pop", simplify_output = TRUE, verbose = FALSE)

```

## prepare the plot

```{r PC}
std_additions <- function(x){
  x <- x +
    scale_color_manual(values = colors) +
    guides(color = "none") +
    theme(axis.title = element_blank(),
          axis.text = element_blank())
  return(x)
}

PC <- plot_grid(std_additions(pcad_basep$pca) + ggtitle("MGC = 1, Max % Missing = 50") + 
                  theme(plot.title = element_text(size = 18, hjust = .5)),
                plot_grid(std_additions(pcad_maf05p$pca) + ggtitle("MAF = 0.05") + 
                            theme(plot.title = element_text(size = 18, hjust = .5)),
                          std_additions(pcad_miss75p$pca) + ggtitle("Max % Missing = 25%") + 
                            theme(plot.title = element_text(size = 18, hjust = .5)),
                          ncol = 1),
                ncol = 2)

save_plot("../manuscript/final_figures/Figure_Box1_PC.pdf", PC, base_height = 11, base_width = 7.5)

```
# Combine everything into the final plot

```{r final_plot}
FB1 <- plot_grid(PA,
                 plot_grid(PB, PC, nrow = 1),
                 ncol = 1)

save_plot("../manuscript/final_figures/Box_1_Figure.pdf", FB1, base_width = 15, base_height = 22)
```


