---
title: "coala_sims"
output: html_document
date: "2023-10-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(snpR); library(data.table); library(coala); # library(GeneArchEst)
# remotes::install_github("hemstrow/GeneArchEst")
```

# Define parameters

```{r}
N0 <- 10000 # starting population size (at present)
mu <- 1e-8 # per-base mutation rate
len <- 10000000 # chromosome length
r <- 1 # average number of recombination events per chr
g <- 1 # years per gen
t1 <- 500 # time of ingroup split
t2 <- 1000 # time of outgroup split
tb <- 50 # time of bottleneck/growth for size change models
m <- 2/N0 # number of migrants per gen, near isolation (Fst ~ .1); 2/N0, 15/N0, 18/N0 for near isolation, mod geneflow, high geneflow
change_size <- .10 # proportion change, .1 for bottle, 1.9 for expansion
samples <- 50 # sample size
time_selection <- 50 # time where selection starts
starting_selection_freq <- 1/(2*N0) # starting frequencing of allele under selection; hard 1/(2N), soft .2
selection_strength <- 4000
nloci <- 10
do_size_change <- TRUE
do_selection <- FALSE

output_file_name <- "path/to/output.RDS"
```

# Define models
## Basic model
```{r}
model_basic <- coal_model(sample_size = c(samples, samples, samples), loci_number = nloci, ploidy = 2) +
  feat_mutation(rate = par_expr(4*N0*mu*len)) + # 4*N*mu, where mu is mut. rate per locus
  feat_recombination(rate = par_expr(4*N0*r)) + # 4*N*r, where r is the probability that a recombination event within the locus occurs in one generation.
  feat_pop_merge(par_expr(t1/(4*N0*g)), 3, 2) + #pop. 3 merges into pop. 2, 0.5 coal. units in the past
  feat_pop_merge(par_expr(t2/(4*N0*g)), 2, 1) + #pops. 2+3 merge into pop. 1, 0.3 coal. units before 2+3 divergence
  feat_migration(rate = par_expr(4 * N0 * m), pop_from = 2, pop_to = 3) + 
  sumstat_seg_sites() + # generate segregating snps
  par_named("N0") +
  par_named("mu") +
  par_named("r") +
  par_named("g") +
  par_named("t1") +
  par_named("t2") +
  par_named("m")

# for the one chr under selection
model_basic_sel <- coal_model(sample_size = c(samples, samples, samples), loci_number = 1, ploidy = 2) +
  feat_mutation(rate = par_expr(4*N0*mu*len)) + # 4*N*mu, where mu is mut. rate per locus
  feat_recombination(rate = par_expr(4*N0*r)) + # 4*N*r, where r is the probability that a recombination event within the locus occurs in one generation.
  feat_pop_merge(par_expr(t1/(4*N0*g)), 3, 2) + #pop. 3 merges into pop. 2, 0.5 coal. units in the past
  feat_pop_merge(par_expr(t2/(4*N0*g)), 2, 1) + #pops. 2+3 merge into pop. 1, 0.3 coal. units before 2+3 divergence
  feat_migration(rate = par_expr(4 * N0 * m), pop_from = 2, pop_to = 3) + 
  sumstat_seg_sites() + # generate segregating snps
  feat_selection(strength_A = selection_strength, 
                 time = par_expr(time_selection/(4*N0*g)), 
                 population = 3, 
                 start = TRUE,
                 start_frequency = starting_selection_freq,
                 Ne = N0,
                 position = 0.25,
                 force_keep = TRUE,
                 locus_group = 1) +
  par_named("N0") +
  par_named("mu") +
  par_named("r") +
  par_named("g") +
  par_named("t1") +
  par_named("t2") +
  par_named("m") +
  par_named("time_selection")
```

## bottleneck/expansion
```{r}
model_size_change <- model_basic +
  feat_size_change(new_size = par_named("b_size"), 3, time = 0) +
  feat_size_change(new_size = 1, 3, time = par_expr(tb/(4*N0*g))) +
  par_named("tb")

model_size_change_sel <- model_basic_sel + 
  feat_size_change(new_size = par_named("b_size"), 3, time = 0) +
  feat_size_change(new_size = 1, 3, time = par_expr(tb/(4*N0*g))) +
  par_named("tb")
```

# run model
```{r}
if(!do_size_change){
  sim <- simulate(model_basic, seed = 123, pars = c(N0 = N0, len = len,
                                                    r = r, g = g, t1 = t1, t2 = t2, 
                                                    tb = tb, mu = mu, m = m))
  if(do_selection){
    activate_msms("/usr/bin/msms3.2rc-b163.jar", "C://Program Files (x86)/Java/jre1.8.0_361/bin/java.exe")
    genos_chr11 <- simulate(model_basic_sel, seed = 123, pars = c(N0 = N0, len = len,
                                                                  r = r, g = g, t1 = t1, t2 = t2, 
                                                                  tb = tb, mu = mu, m = m,
                                                                  time_selection = time_selection))
  }
}

if(do_size_change){
  sim <- simulate(model_size_change, seed = 123, pars = c(N0 = N0, len = len,
                                                          r = r, g = g, t1 = t1, t2 = t2, 
                                                          tb = tb, mu = mu, m = m, 
                                                          b_size = change_size))
  if(do_selection){
    activate_msms("/usr/bin/msms3.2rc-b163.jar", "C://Program Files (x86)/Java/jre1.8.0_361/bin/java.exe")
    genos_chr11 <- simulate(model_size_change_sel, seed = 123, pars = c(N0 = N0, len = len,
                                                                        r = r, g = g, t1 = t1, t2 = t2, 
                                                                        tb = tb, mu = mu, m = m,
                                                                        time_selection = time_selection, 
                                                                        b_size = change_size))
  }
}


```

# parse
```{r}
genos <- sim$seg_sites
meta <- vector("list", length(genos))
for(i in 1:length(genos)){
  meta[[i]] <- data.table(chr = i, position = floor(as.numeric(genos[[i]]$position)*len))
  genos[[i]] <- genos[[i]]$snps[seq(1, nrow(genos[[i]]), 2),] +
    genos[[i]]$snps[seq(2, nrow(genos[[i]]), 2),]
  genos[[i]] <- t(genos[[i]])
  genos[[i]] <- as.data.table(genos[[i]])
}

if(do_selection){
  # add on chr 11
  meta[[i + 1]] <- data.table(chr = i + 1, position = floor(as.numeric(genos_chr11$seg_sites[[1]]$position)*len))
  genos[[i + 1]] <- genos_chr11$seg_sites[[1]]$snps[seq(1, nrow(genos_chr11$seg_sites[[1]]), 2),] +
    genos_chr11$seg_sites[[1]]$snps[seq(2, nrow(genos_chr11$seg_sites[[1]]), 2),]
  genos[[i + 1]] <- t(genos[[i + 1]])
  genos[[i + 1]] <- as.data.table(genos[[i + 1]])
}



meta <- rbindlist(meta)
genos <- rbindlist(genos)

saveRDS(list(genos = genos, meta = meta), output_file_name)


# srd <- import.snpR.data(genos, sample.meta = data.frame(pop = rep(c("A", "B", "C"), each = 50)),
#                         snp.meta = meta)
# 
# plot_clusters(srd, "pop")
# srd <- calc_tajimas_d(srd, "pop", global = TRUE)
# get.snpR.stats(srd, "pop", "tajimas_d")
# srd <- calc_pairwise_fst(srd, "pop")
# get.snpR.stats(srd, "pop", "fst")$weighted.means
# 
# # selection detection
# srd <- calc_pairwise_fst(srd, "pop")
# srd <- calc_pi(srd, "pop")
# plot_manhattan(srd, "fst", facets = "pop")
# plot_manhattan(srd, "pi", facets = "pop")

```
